============================== Run Docker Compose ==============================
docker compose up -d

============================== Local Run ==============================
# Start just Postgres
sudo docker compose up -d postgres

# (optional) make sure the app container is stopped so port 8080 is free
sudo docker compose stop app

1)
mvn spring-boot:run   -Dspring-boot.run.profiles=mvc-vt   -Dspring-boot.run.arguments="\
    --spring.datasource.url=jdbc:postgresql://localhost:5432/appdb \
    --spring.datasource.username=app \
    --spring.datasource.password=app_pw \
    --spring.datasource.hikari.maximum-pool-size=16 \
    --spring.datasource.hikari.connection-timeout=300"

2)
set -a; . ./.env; set +a
mvn spring-boot:run -Dspring-boot.run.profiles=mvc-vt


============================== Tests ==============================
# run the full build lifecycle up to the verify phase:
mvn -q test
mvn -B -ntp verify


============================== Load testing ==============================
# Check how to use docker later

# with envs
BASE_URL=http://localhost:8080 \
RATE=20000 \
DURATION=1m \
BATCH=20 \
AVG_ITER_MS=210 \
k6 run scripts/k6/mix.js

# Same machine, but CPU-pin each process
# Plain processes (Linux)

# Pin Spring Boot to cores 0–3
taskset -c 0-3 \
    -Dspring-boot.run.jvmArguments="-XX:ActiveProcessorCount=4" \
    mvn spring-boot:run   -Dspring-boot.run.profiles=mvc-vt   -Dspring-boot.run.arguments="\
        --spring.datasource.url=jdbc:postgresql://localhost:5432/appdb \
        --spring.datasource.username=app \
        --spring.datasource.password=app_pw \
        --spring.datasource.hikari.maximum-pool-size=16 \
        --spring.datasource.hikari.connection-timeout=300"

# taskset -c 0-3 binds the JVM to cores 0,1,2,3
#-XX:ActiveProcessorCount=4 keeps JVM thread/GC sizing consistent with the 4 cores

# Pin k6 to cores 4–7
GOMAXPROCS=4 taskset -c 4-7 \
    BASE_URL=http://localhost:8080 \
    RATE=20000 \
    DURATION=1m \
    BATCH=20 \
    AVG_ITER_MS=210 \
    k6 run scripts/k6/mix.js

# GOMAXPROCS=4 matches the 4 pinned cores and reduces scheduler overhead.

# Verify bindings
# Srping
pidof java |pidof java | xargs -I{} taskset -pc {}
xargs -I{} taskset -pc {}

# k6
pidof k6   | xargs -I{} taskset -pc {}



# Read seeded rows
curl http://localhost:8080/orders/1
curl http://localhost:8080/orders/2

# Create a new order
curl -X POST http://localhost:8080/orders \
  -H 'Content-Type: application/json' \
  -d '{"customer":"charlie","totalCents":1999}'
